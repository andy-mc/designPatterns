TODO:
1) Factory: Comúnmente utilizado en muchas aplicaciones para abstraer la creación de objetos.
2) Singleton: A pesar de que puede llevar a problemas si se abusa de él, sigue siendo ampliamente utilizado.
3) Observer: Fundamental en programación reactiva y GUI, muy relevante en frameworks modernos.
4) Strategy: Aplicado frecuentemente para seleccionar algoritmos en tiempo de ejecución.
5) Facade: Utilizado para simplificar interfaces complejas y es común en bibliotecas y sistemas.
6) Decorator: Popular en la mejora de objetos, usado en frameworks y herramientas de desarrollo.
7) Command: Ampliamente usado en GUI y para operaciones deshacer/rehacer, así como en sistemas de colas de trabajo.
8) Adapter: Fundamental cuando se integran sistemas y librerías que de otra manera serían incompatibles.
9) State: Utilizado para gestionar estados en sistemas complejos, particularmente en sistemas de estados finitos.
10) Template Method: Aún utilizado en frameworks y librerías donde se requieren algoritmos con pasos invariantes.
11) Proxy: Muy relevante en situaciones como la carga perezosa y el control de acceso.
12) Iterator: Aunque a menudo integrado en lenguajes modernos, su concepto sigue siendo fundamental para la iteración.
13) Composite: Utilizado para diseñar estructuras de objetos que contienen tanto composiciones de objetos como objetos individuales.
14) Builder: Esencial para la construcción de objetos complejos, particularmente donde se requiere inmutabilidad.
15) Chain of Responsibility: Utilizado en el manejo de solicitudes donde varios objetos pueden tratar la solicitud.
16) Mediator: Importante para disminuir el acoplamiento entre clases que se comunican.
17) Memento: Utilizado en el patrón deshacer/rehacer y en el almacenamiento de estados temporales.
18) Bridge: Utilizado para desacoplar abstracciones de implementaciones, aunque menos frecuente que otros patrones estructurales.
19) Prototype: Utilizado en la creación de objetos cuando es más eficiente clonar que instanciar, particularmente en prototipado rápido.
20) Flyweight: Utilizado en optimización de rendimiento y memoria, principalmente en entornos con recursos limitados.
21) Visitor: Utilizado para operaciones sobre conjuntos de elementos, como en la manipulación de ASTs en compiladores.
22) Interpreter: Aplicado en lenguajes específicos de dominio (DSLs), pero su uso es más especializado.
23) Command: Utilizado en aplicaciones que requieren acciones encapsuladas, como transacciones o acciones de deshacer/rehacer.

DONE:
